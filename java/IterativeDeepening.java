import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class IterativeDeepening extends Search{
	
	Position A;
	Position B;
	Position C;
	Position agent;
	
	public IterativeDeepening(int[][] initState, int[][] goalState, int N, Position A, Position B, Position C, Position agent) {
		super(initState, goalState, N);
		// TODO Auto-generated constructor stub
		
		this.A = A;
		this.B = B;
		this.C = C;
		
		this.agent = agent;
	}
	
	public void IDS() {
		Grid startNode = new Grid(initState, A, B, C, agent);
		
		for(int depth = 0; depth < Integer.MAX_VALUE; depth ++) {
			Grid found = DLS(startNode, depth, 0);
			
			if(found != null) {
				retracePath(found);
				return;
			}
		}
	}
	
	public Grid DLS(Grid current, int depth, int running_time) {
		RUNNING_TIME = running_time;
		current.nodesGeneratedBefore = RUNNING_TIME;
		if(depth == 0 && current.checkGoalState()) {
			return current;
		}
		if(depth > 0) {
			for(Grid neighbor : current.getNeighbors(current)) {
				
				Grid found = DLS(neighbor, depth - 1, RUNNING_TIME + 1);
				if(found != null) {
					return found;
				}
			}
		}
		
		return null;
	}
	
	private void retracePath(Grid node) {
		Grid currentNode = node;
		
		List<Grid> path = new ArrayList<>();
		while(currentNode != null) {
			path.add(currentNode);
			currentNode = currentNode.parent;
		}
		
		Collections.reverse(path);
		
		for(Grid g : path) {
			g.printState();
			System.out.println("Number of nodes generated by now " + g.nodesGeneratedBefore);
			System.out.println();
			
		}
	}

}
