import java.util.*;

public class Astar extends Search {
	
	Position A;
	Position B;
	Position C;
	Position agent;
	
	public Astar(int[][] initState, int[][] goalState, int N, Position A, Position B, Position C, Position agent) {
		super(initState, goalState, N);
		// TODO Auto-generated constructor stub
		this.A = A;
		this.B = B;
		this.C = C;
		this.agent = agent;
	}

	public Grid astar(){
		
		Grid node = new Grid(initState, A, B, C, agent);
		
		// Initialize both open and closed list.
        List<Grid> openList = new ArrayList<>();
        Set<Grid> closedList = new HashSet<>();
        
        openList.add(node);
        
        while(!openList.isEmpty()) {
        	Grid currentGrid = openList.get(0);
        	int currentIndex = 0;
        	
        	// search for node with least cost
        	// Most expensive part of the algorithm
        	for(int i = 0; i < openList.size(); i ++) {
        		Grid candidate = openList.get(i);
        		
        		if(candidate.fCost < currentGrid.fCost || candidate.fCost == currentGrid.fCost && candidate.hCost < currentGrid.hCost) {
        			currentGrid = candidate;
        			currentIndex = i;
        		}
        		
        	}
        	
        	// pop current off open list, add to closed list.
        	openList.remove(currentIndex);
        	closedList.add(currentGrid);
        	//By adding a node to the closed list that means we EXPAND it!
        	Search.RUNNING_TIME ++;
        	currentGrid.nodesGeneratedBefore = Search.RUNNING_TIME;
        	
        	//check for goal state.
        	if(currentGrid.checkGoalState()) {
        		System.out.println("Found goal state");
        		retraceBack(currentGrid);
        		System.out.println(Search.RUNNING_TIME);
        		return currentGrid;
        	}
        	
        	for(Grid neighbor : currentGrid.getNeighbors(currentGrid)) {
        		if(closedList.contains(neighbor))
        			continue;
        		
        		int newMovementCostToNeighbor = currentGrid.gCost + 1;
        		
        		if( newMovementCostToNeighbor < currentGrid.gCost || !openList.contains(neighbor) ) {
        			
        			neighbor.gCost = newMovementCostToNeighbor;
        			neighbor.hCost = euclidianDistance2(neighbor);
        			neighbor.fCost = neighbor.gCost + neighbor.hCost;
        			
        			if(!openList.contains(neighbor)) {
        				openList.add(neighbor);
        			}
        			
        		}
        		
        	}
        }
        return null;
		
	}
	
	private void retraceBack(Grid currentGrid) {
		
		Grid grid = currentGrid;
		List<Grid> path = new ArrayList<Grid>();
		while(grid != null) {
			path.add(grid);
			grid = grid.parent;
		}
		
		Collections.reverse(path);
		
		for(Grid g : path) {
			System.out.println();
			g.printState();
			System.out.println("Number of nodes generated by now " + g.nodesGeneratedBefore);
		}
		System.out.println(RUNNING_TIME);
	}
	
	private int euclidianDistance(Grid c) {
		int da = (int)Math.sqrt( Math.pow(goalPositionA.x - c.A.x, 2) + (int)Math.pow(goalPositionA.y - c.A.y, 2) );
		int db = (int)Math.sqrt( Math.pow(goalPositionB.x - c.B.x, 2) + (int)Math.pow(goalPositionB.y - c.B.y, 2) );
		int dc = (int)Math.sqrt( Math.pow(goalPositionC.x - c.C.x, 2) + (int)Math.pow(goalPositionC.y - c.C.y, 2) );
		return da + db + dc;
	}
	
	private int euclidianDistance2(Grid c) {
		int da = (int)Math.pow(goalPositionA.x - c.A.x, 2) + (int)Math.pow(goalPositionA.y - c.A.y, 2);
		int db = (int)Math.pow(goalPositionB.x - c.B.x, 2) + (int)Math.pow(goalPositionB.y - c.B.y, 2);
		int dc = (int)Math.pow(goalPositionC.x - c.C.x, 2) + (int)Math.pow(goalPositionC.y - c.C.y, 2);
		
		return da + db + dc;
	}

}
